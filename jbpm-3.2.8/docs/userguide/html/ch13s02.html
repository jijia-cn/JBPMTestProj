<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>An example</title><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="JBoss jBPM - Workflow in Java"><link rel="up" href="ch13.html" title="Chapter&nbsp;13.&nbsp;Asynchronous continuations"><link rel="prev" href="ch13.html" title="Chapter&nbsp;13.&nbsp;Asynchronous continuations"><link rel="next" href="ch13s03.html" title="The job executor"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">An example</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch13.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;13.&nbsp;Asynchronous continuations</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch13s03.html">Next</a></td></tr></table><hr></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="anexample"></a>An example</h2></div></div></div><p>Normally, a node is always executed after a token has entered the node.  So the node is 
      executed in the thread of the client.  We'll explore asynchronous continuations by looking 
      two examples.  The first example is a part of a process with 3 nodes.  Node 'a' is a wait 
      state, node 'b' is an automated step and node 'c' is again a wait state.  This process does 
      not contain any asynchronous behaviour and it is represented in the picture below.
    </p><p>The first frame, shows the starting situation.  The token points to node 'a', meaning 
      that the path of execution is waiting for an external trigger.  That trigger must be given 
      by sending a signal to the token.  When the signal arrives, the token will be passed from 
      node 'a' over the transition to node 'b'.  After the token arrived in node 'b', node 'b' 
      is executed.  Recall that node 'b' is an automated step that does not behave as a wait 
      state (e.g. sending an email).  So the second frame is a snapshot taken when node 'b' is 
      being executed.  Since node 'b' is an automated step in the process, the execute of node 
      'b' will include the propagation of the token over the transition to node 'c'.  Node 'c'
      is a wait state so the third frame shows the final situation after the signal method 
      returns.
    </p><div class="figure"><a name="async1.image"></a><p class="title"><b>Figure&nbsp;13.1.&nbsp;Example 1: Process without asynchronous continuation</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/async1.gif" align="middle" alt="Example 1: Process without asynchronous continuation"></div></div></div><br class="figure-break"><p>While persistence is not mandatory in jBPM, the most common scenario is that a signal 
      is called within a transaction.  Let's have a look at the updates of that transaction.  
      First of all, the token is updated to point to node 'c'.  These updates are generated by 
      hibernate as a result of the <code class="literal">GraphSession.saveProcessInstance</code> on a 
      JDBC connection.  Second, in case the automated action would access and update some 
      transactional resources, those transactional updates should be combined or part of 
      the same transaction.
    </p><p>Now, we are going to look at the second example, the second example is a variant of 
      the first example and introduces an asynchronous continuation in node 'b'.  Nodes 'a' and 
      'c' behave the same as in the first example, namely they behave as wait states.  In jPDL,
      a node is marked as asynchronous by setting the attribute <code class="literal">async="true"</code>.
    </p><p>The result of adding <code class="literal">async="true"</code> to node 'b' is that the process 
      execution will be split up into 2 parts.  The first part will execute the process up to 
      the point where node 'b' is to be executed.  The second part will execute node 'b' and 
      that execution will stop in wait state 'c'.
    </p><p>The transaction will hence be split up into 2 separate transactions.  One transaction 
      for each part.  While it requires an external trigger (the invocation of the 
      <code class="literal">Token.signal</code> method) to leave node 'a' in the first transaction, jBPM 
      will automatically trigger and perform the second transaction.
    </p><div class="figure"><a name="asynchronous.continuations.image"></a><p class="title"><b>Figure&nbsp;13.2.&nbsp;Example 2: A process with asynchronous continuations</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/asynchronous.continuations.gif" align="middle" alt="Example 2: A process with asynchronous continuations"></div></div></div><br class="figure-break"><p>For actions, the principle is similar.  Actions that are marked with the 
      attribute <code class="literal">async="true"</code> are executed outside of the thread that 
      executes the process.  If persistence is configured (it is by default), the actions 
      will be executed in a separate transaction.
    </p><p>In jBPM, asynchronous continuations are realized by using an asynchronous messaging 
      system.  When the process execution arrives at a point that should be executed 
      asynchronously, jBPM will suspend the execution, produces a command message and send it 
      to the command executor. The command executor is a separate component that, upon receipt 
      of a message, will resume the execution of the process where it got suspended.
    </p><p>jBPM can be configured to use a JMS provider or its built-in asynchronous messaging
      system.  The built-in messaging system is quite limited in functionality, but allowes 
      this feature to be supported on environments where JMS is unavailable.
    </p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch13.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch13.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch13s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;13.&nbsp;Asynchronous continuations&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;The job executor</td></tr></table></div></body></html>